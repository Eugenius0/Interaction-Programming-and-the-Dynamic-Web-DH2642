import{e}from"./index-6400038e.js";import{w as p,a as c}from"./mockFetch-ba9030b0.js";import{i as w,f as v,s as t}from"./mockFirebase-8bba77fc.js";import{g as q}from"./filesToTest-e54ca7e1.js";import"./shim-7e3475d3.js";import"./util-004fc0f1.js";const M="",u=await q(`/src/${M}firebaseModel.js`);describe("TW3.4.1 Firebase-model",function(){this.timeout(2e5),before(function(){u||this.skip(),u.modelToPersistence||this.skip()}),it("modelToPersistence",function(){w()}),it("saveToFirebase persists the result of modelToPersistence _only_ if model.ready is truthy",async function(){u.saveToFirebase||this.skip();const{numberOfGuests:i,dishes:h,currentDishId:d}=v(),s={setNumberOfGuests(o){this.numberOfGuests=o},setCurrentDishId(o){this.currentDishId=o},numberOfGuests:5,dishes:[{id:24},{id:42}],currentDishId:24,ready:!0};t.setHistory=[],u.saveToFirebase(s),e(t.setHistory.length,"saveToFirebase performs a firebase set() operation").to.equal(1),e(t.setHistory[0].val,"data saved to firebase is the one from the model (via modelToPersistence)").to.eql({[i]:5,[h]:[24,42],[d]:24}),s.ready=!1,t.setHistory=[],u.saveToFirebase(s),e(t.setHistory.length,"if model.ready is false, nothing is set() to firebase").to.equal(0)}),it("persistenceToModel",async function(){u.persistenceToModel||this.skip();const{numberOfGuests:i,dishes:h,currentDishId:d}=v();let s;const o={setNumberOfGuests(n){this.numberOfGuests=n},setCurrentDishId(n){this.currentDishId=n,s=!0},dishes:[]},r={...o},a={...o},b={...o};let f;await p(c,async function(){u.persistenceToModel({[i]:32,[h]:[49,42],[d]:22},o)?.then?.(y=>f="returned")}),e(o.currentDishId,"the current dish set in the model should be the same as in the cloud").to.equal(22),e(s,"persistenceToModel should call setCurrentDishId").to.equal(!0),e(o.numberOfGuests,"the number of guests set in the model should be the same as in the cloud").to.equal(32),e(o.dishes).to.be.an("array"),e(o.dishes.map(n=>n.id).sort(),"the dishes set in the model should be retrieved from the API based on the IDs from the cloud").to.eql([42,49]),o.dishes.forEach(n=>e(Object.values(n).length>1,"dishes stored in the model should contain all dish properties, not just IDs").to.be.ok),e(c.lastFetch,"persistenceToModel should call getMenuDetails, passing the given dish IDs").to.include("49"),e(c.lastFetch,"persistenceToModel should call getMenuDetails, passing the given dish IDs").to.include("42"),e(f,"persistenceToModel should return a promise, so the caller can wait for all dishes to be retrieved").to.be.ok,f=null,s=null,await p(c,async function(){u.persistenceToModel({[i]:7,[d]:21},b)?.then?.(y=>f="returned")}),e(b.currentDishId,"the current dish set in the model should be the same as in the cloud").to.equal(21),e(s,"persistenceToModel should call setCurrentDishId").to.equal(!0),e(b.numberOfGuests,"the number of guests set in the model should be the same as in the cloud").to.equal(7),e(b.dishes).to.be.an("array");const D="when there are no dish IDs in the cloud, persistenceToModel should call getMenuDetails with an empty array parameter, or not call it at all";e(c.lastFetch,D).to.not.include("undefined"),e(c.lastFetch,D).to.not.include("null"),e(b.dishes,"when there are no dish IDs in the cloud, the model dishes should be an empty array").to.eql([]),e(f,"persistenceToModel should return a promise, so the caller can wait for all dishes to be retrieved").to.be.ok;let g;await p(c,async function(){return u.persistenceToModel(null,r)?.then?.(n=>g="returned")}),e(r.currentDishId,"if there is no data in the cloud, currentDishId should be set to null or not defined").to.not.be.ok,e(r.numberOfGuests,"if there is no data in the cloud, number of guests should be set to 2").to.equal(2),e(r.dishes.map(n=>n.id),"if there is no data in the cloud, the model dishes should be set to an empty array").to.eql([]),e(g,"persistenceToModel should still return a promise even when there are no dish IDs in the cloud").to.be.ok;let F;await p(c,async function(){return u.persistenceToModel({},a)?.then?.(n=>F="returned")}),e(a.currentDishId,"if there is no current dish id in the cloud, currentDishId should be set to null or not defined").to.not.be.ok,e(a.numberOfGuests,"if there is no number of guests in the cloud, number of guests should be set to 2").to.equal(2),e(a.dishes.map(n=>n.id),"if there is no dishes data in the cloud, the model dishes should be set to an empty array").to.eql([]),e(F,"persistenceToModel should still return a promise even when there are no dish IDs in the cloud").to.be.ok}),it("readFromFirebase passes get() result to persistenceToModel and waits for it to resolve. Set model.ready to false during this process!",async function(){u.readFromFirebase||this.skip(),t.getHistory=[];const{numberOfGuests:i,dishes:h,currentDishId:d}=v();t.data={[i]:13,[h]:[45,42,22],[d]:42};const s={setNumberOfGuests(a){this.numberOfGuests=a},setCurrentDishId(a){this.currentDishId=a},dishes:[],ready:!0};let o,r;p(c,async function(){r=u.readFromFirebase(s),o=s.ready}),await r,I("readFromFirebase ",s,o,{numberOfGuests:i,dishes:h,currentDishId:d}),t.setHistory=[],u.saveToFirebase({numberOfGuests:2,ready:!0,dishes:[]}),e(t.getHistory[0].ref,"saveToFirebase and readFromFirebase use the same REF").to.eql(t.setHistory[0].ref)});function I(l,i,h,{numberOfGuests:d,dishes:s,currentDishId:o}){e(h,l+" should set model.ready to false before attempting a get()").to.equal(!1),e(t.getHistory.length,l+" makes a get() call").to.equal(1),t.data[s].forEach(r=>e(c.lastFetch,l+"readFromFirebase initiates getMenuDetails promise").to.include(r)),e(i.numberOfGuests,l+"sets data from firebase get() into the model (nr. guests)").to.equal(t.data[d]),e(i.currentDishId,l+"sets data from firebase get() into the model (current dish)").to.equal(t.data[o]),e(i.dishes,l+": when readFromFirebase resolves, model dishes should be an array").to.be.an("array"),e(i.dishes?.map(r=>r.id),l+": when readFromFirebase resolves, dishes retrieved via getMenuDetails() should be set into the model. Did you return the result of persistenceToModel in the then()?").to.eql(t.data[s]),e(i.ready,l+": when readFromFirebase resolves, model.ready is set to true").to.equal(!0)}it("connectToFirebase",async function(){u.connectToFirebase||this.skip(),t.getHistory=[];const{numberOfGuests:i,dishes:h,currentDishId:d}=v();t.data={[i]:11,[h]:[45,42,22],[d]:22};const s={setNumberOfGuests(m){this.numberOfGuests=m},setCurrentDishId(m){this.currentDishId=m},dishes:[],ready:!0};let o,r,a,b;await p(c,async function(){u.connectToFirebase(s,function(m,T){return r=m,a=T,function(){b=!0}}),o=s.ready,await c.lastFetch}),I("connectToFirebase calls saveToFirebase; ",s,o,{numberOfGuests:i,dishes:h,currentDishId:d}),e(r,"first side-effect argument must be a function (callback)").to.be.a("function"),e(a,"second side-effect argument must be a function (callback)").to.be.a("function");let f;try{f=r()}catch(m){e.fail("runtime error in the first side-effect ACB: "+m.toString())}e(f,"the first side-effect ACB should return a value to check").to.be.ok,e(b,"function returned by the side effect must not be called, as that cancels the effect").to.not.be.ok;const D="the first ACB passed to the side-effect should always return a defined value";s.numberOfGuests=12;const g=r();e(g,D).to.be.ok,s.dishes=s.dishes.slice(1);const F=r();e(F,D).to.be.ok,s.currentDishId=42;const n=r();e(n,D).to.be.ok;const y="the first ACB passed to the side-effect should return a different object/array whenever there is a change in model nr guests, dish array or currentDishId";e(f,y).to.not.deep.equal(g),e(f,y).to.not.deep.equal(F),e(f,y).to.not.deep.equal(n),e(g,y).to.not.deep.equal(F),e(g,y).to.not.deep.equal(n),e(F,y).to.not.deep.equal(n),t.setHistory=[];try{a()}catch(m){e.fail("runtime error in the second side-effect ACB: "+m.toString())}e(t.setHistory.length,"second ACB passed to the side-effect calls saveToFirebase, which performs a firebase set() operation").to.equal(1),e(t.setHistory[0].val,"second ACB passed to the side-effect calls saveToFirebase: data saved to firebase is the one from the model (via modelToPersistence)").to.eql({[i]:12,[h]:[22,42],[d]:42}),s.ready=!1,t.setHistory=[];try{a()}catch(m){e.fail("runtime error in the second side-effect ACB: "+m.toString())}e(t.setHistory.length,"second ACB passed to the side-effect calls saveToFirebase: if model.ready is false, nothing is set() to firebase").to.equal(0)}),it("live update (optional): readFromFirebase invokes onValue() to copy cloud data into the model",async function(){t.onHistory=[],t.getHistory=[];const i={setNumberOfGuests(a){this.numberOfGuests=a},setCurrentDishId(a){this.currentDishId=a}};await p(c,async function(){await u.readFromFirebase(i)}),t.onHistory.length||this.skip();const{numberOfGuests:h,dishes:d,currentDishId:s}=v(),o=t.onHistory[0].acb;e(o,"a callback is passed to onValue()").to.be.a("function"),e(t.getHistory[0].ref,"get() and onState() are performed on the same REF").to.eql(t.onHistory[0].ref);const r={[h]:15,[d]:[45,42,21],[s]:42};await p(c,function(){o({val(){return r}})}),r[d].forEach(a=>e(c.lastFetch,"firebase promise chain initiates getMenuDetails promise").to.include(a)),e(i.numberOfGuests,"data from firebase onValue() is set into the model (nr. guests)").to.equal(r[h]),e(i.currentDishId,"data from firebase onValue() is set into the model (current dish)").to.equal(r[s]),e(i.dishes.map(a=>a.id),"dihes with the IDs from firebase onValue() are retrieved via getMenuDetails and set into the model").to.eql(r[d])})});
